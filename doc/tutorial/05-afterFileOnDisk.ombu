OmEntry {	#tags : {		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #GtExamplesTutorial\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'GToolkit-Examples-Dummies-Tutorial\''			},			#name : #GtExamplesTutorial,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GtExamplesTutorial class\r\tinstanceVariableNames: \'\''				},				#name : #'GtExamplesTutorial class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @6			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GtExamplesTutorial,					#isMetaSide : false				},				#parent : @6,				#content : '!An example to start with\r\rLet us setup to exemplify how to create a file with some contents using the FileSystem. We create a straightforward unary method:\r\r[[[epicea=01-createFileOnDisk.ombu]]]\r\r[[[example=GtExamplesTutorial>>#createFileInMemory|show=gtContentsIn:]]]\r\rThe Pragma ==<gtExample>== converts any regular method into a ==GtExample==. The name of the method can be arbitrary.\r\rA ==GtExample== might be annotated with additional and optional meta-information like ==#label:== (a title or very short description), ==#description:== (a long description explaining the intention of the example) or ==#icon:==.\r\r[[[epicea=02-createFileOnDisk.ombu]]]\r\r!!Example dependencies\r\rAs examples return objects, we can use those objects to compose other objects that in their turn can also constitute examples. To support this, examples may be chained to form trees (or even graphs) of depending examples.\r\rConfused? Let\'s look at our example. There are at least three interesting objects in one single method:\r- [A] the file reference\r- [B] the string contents\r- [C] the file reference with string contents\r\rIf we want to decompose them, we can use dependencies:\r\r[[[epicea=03-fileContents-fileReference.ombu]]]\r\rIn the example above, the example [A] depends on the examples [B] and [C]. The order of declaration is important and maps to the arguments order declared by the method of example [A]. At runtime, examples that declare dependencies, receive the return values of their depending examples as arguments. As a consequence, the execution order goes bottom up.\r\rThe dependencies can also be navigated visually:\r\r[[[example=GtExamplesTutorial>>#createFileInMemory|show=gtContentsIn:]]]\r\r!Cleaning up after using an example\r\rIn the current scenario, the file is created in memory. But, what would happen if the examples would create it on disk? Let\'s create one to explore the situation:\r\r[[[epicea=04-fileOnDisk.ombu]]]\r\r[[[example=GtExamplesTutorial>>#createFileOnDisk|show=gtContentsIn:]]]\r\rAt first sight, we got the same result. However, one issue with our current example scenario is that the file created in ==#createFileOnDisk== has the side effect of leaving that file reside on disk. In this situation we would like to cleanup such artifacts after running an example. We can do that with the declaration of a so called after-method.\r\r',				#stamp : 'TudorGirba 5/6/2018 21:51'			},			#classVariables : OrderedCollection [ ],			#category : #GToolkit-Examples-Dummies-Tutorial,			#package : #GToolkit-Examples-Dummies,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #GtExamplesTutorial\r\tinstanceVariableNames: \'fileOnDisk\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'GToolkit-Examples-Dummies-Tutorial\''			},			#name : #GtExamplesTutorial,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #GtExamplesTutorial,						#isMetaSide : false					},					#name : #fileOnDisk,					#parent : @20				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GtExamplesTutorial class\r\tinstanceVariableNames: \'\''				},				#name : #'GtExamplesTutorial class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @20			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GtExamplesTutorial,					#isMetaSide : false				},				#parent : @20,				#content : '!An example to start with\r\rLet us setup to exemplify how to create a file with some contents using the FileSystem. We create a straightforward unary method:\r\r[[[epicea=01-createFileOnDisk.ombu]]]\r\r[[[example=GtExamplesTutorial>>#createFileInMemory|show=gtContentsIn:]]]\r\rThe Pragma ==<gtExample>== converts any regular method into a ==GtExample==. The name of the method can be arbitrary.\r\rA ==GtExample== might be annotated with additional and optional meta-information like ==#label:== (a title or very short description), ==#description:== (a long description explaining the intention of the example) or ==#icon:==.\r\r[[[epicea=02-createFileOnDisk.ombu]]]\r\r!!Example dependencies\r\rAs examples return objects, we can use those objects to compose other objects that in their turn can also constitute examples. To support this, examples may be chained to form trees (or even graphs) of depending examples.\r\rConfused? Let\'s look at our example. There are at least three interesting objects in one single method:\r- [A] the file reference\r- [B] the string contents\r- [C] the file reference with string contents\r\rIf we want to decompose them, we can use dependencies:\r\r[[[epicea=03-fileContents-fileReference.ombu]]]\r\rIn the example above, the example [A] depends on the examples [B] and [C]. The order of declaration is important and maps to the arguments order declared by the method of example [A]. At runtime, examples that declare dependencies, receive the return values of their depending examples as arguments. As a consequence, the execution order goes bottom up.\r\rThe dependencies can also be navigated visually:\r\r[[[example=GtExamplesTutorial>>#createFileInMemory|show=gtContentsIn:]]]\r\r!Cleaning up after using an example\r\rIn the current scenario, the file is created in memory. But, what would happen if the examples would create it on disk? Let\'s create one to explore the situation:\r\r[[[epicea=04-fileOnDisk.ombu]]]\r\r[[[example=GtExamplesTutorial>>#createFileOnDisk|show=gtContentsIn:]]]\r\rAt first sight, we got the same result. However, one issue with our current example scenario is that the file created in ==#createFileOnDisk== has the side effect of leaving that file reside on disk. In this situation we would like to cleanup such artifacts after running an example. We can do that with the declaration of a so called after-method.\r\r',				#stamp : 'TudorGirba 5/6/2018 21:51'			},			#classVariables : OrderedCollection [ ],			#category : #GToolkit-Examples-Dummies-Tutorial,			#package : #GToolkit-Examples-Dummies,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GtExamplesTutorial,				#isMetaSide : false			},			#name : #deleteFileFromDisk,			#protocol : #examples,			#sourceCode : 'deleteFileFromDisk\r\tfileOnDisk ensureDelete',			#stamp : 'TudorGirba 5/6/2018 21:53',			#package : #GToolkit-Examples-Dummies		}	}}OmEntry {	#tags : {		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GtExamplesTutorial,				#isMetaSide : false			},			#name : #createFileOnDisk,			#protocol : #examples,			#sourceCode : 'createFileOnDisk\r\t<gtExample>\r\t<after: #deleteFileFromDisk>\r\t^ fileOnDisk ifNil: [\r\t\tfileOnDisk := self directoryOnDisk / self fileName\r\t\t\t\t\t\t\twriteStreamDo: [ :stream | stream nextPutAll: self fileContents ];\r\t\t\t\t\t\t\tyourself ]',			#stamp : 'TudorGirba 5/7/2018 12:14',			#package : #GToolkit-Examples-Dummies		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GtExamplesTutorial,				#isMetaSide : false			},			#name : #createFileOnDisk,			#protocol : #examples,			#sourceCode : 'createFileOnDisk\r\t<gtExample>\r\t<after: #deleteFileFromDisk>\r\t^ fileOnDisk := self directoryOnDisk / self fileName\r\t\t\twriteStreamDo: [ :stream | stream nextPutAll: self fileContents ];\r\t\t\tyourself',			#stamp : 'TudorGirba 5/7/2018 12:15',			#package : #GToolkit-Examples-Dummies		}	}}